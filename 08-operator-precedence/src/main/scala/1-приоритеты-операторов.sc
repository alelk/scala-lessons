class MyInt(val value: Int) extends AnyVal {

  // методам можно давать операторные имена
  def +(other: MyInt) = new MyInt(value + other.value)

  def -(other: MyInt) = new MyInt(value - other.value)

  def *(other: MyInt) = new MyInt(value * other.value)

  def /(other: MyInt) = new MyInt(value / other.value)

  // если этот метод будет вызван в инфиксной (операторной) форме, то он будет вызыван
  // на ПРАВОМ операнде, а в качестве аргумента ему будет передан ЛЕВЫЙ операнд
  // т.к. этот метод право-ассоциативный, потому что его название заканчивается двоеточием
  def ::(other: MyInt) = new MyInt(s"${other.value}$value".toInt)

  override def toString: String = s"MyInt($value)"
}

val a = new MyInt(10)
val b = new MyInt(20)
val c = new MyInt(2)

// приоритет оператора определяется первым символом его имени - приоритет * выше, чем +
a + b * c // 50
a.+(b.*(c)) // 50
a * b + c // 202
a.*(b).+(c) // 202

// название оператора заканчивается двоеточием - оператор право-ассоциативный
a :: b // 1020
b.::(a) // 1020
b :: a // 2010
a.::(b) // 2010

// данные 2 выражения ПОЧТИ равны. Почти - потому что если бы a, b и c были бы функциями, то они
// были бы вызваны в порядке слева-направо (a, затем b, затем c) а их результаты были бы "свернуты"
// справа-налево
a :: b :: c
c.::(b).::(a)
{val a1 = a; val b1 = b; val c1 = c; c1.::(b1).::(a1)} // наиболее точная альтернатива

// формирование списка из 3 элементов
1 :: 2 :: 3 :: Nil // List(1, 2, 3)

val list = Nil.::(3).::(2).::(1) // List(1, 2, 3)

// добавление в хвост - при этом создается новый список из 4 элементов (список list - немутируемый)
list :+ 4 // List(1, 2, 3, 4)

// добавление в голову - при этом создается новый список из 4 элементов
0 +: list // List(0, 1, 2, 3)

// добавление по одному элементу в хвост и голову
// операторы разного приоритета и разной ассоциативности:
// оператор +: приоритетней оператора :+
// оператор +: право-ассоциативный
// оператор :+ лево-ассоциативный
0 +: list :+ 4 // List(0, 1, 2, 3, 4)
list.+:(0).:+(4) // List(0, 1, 2, 3, 4)

// нельзя использовать в выражении равноприоритетные операторы с разной ассоциативностью (требуется явно расставить скобки)
// 0 +: list + 4.toString // compile error

